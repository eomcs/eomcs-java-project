# mini-pms-v1

## 프로젝트 준비

### 개발 도구 준비하기

- GraalVM(OpenJDK 11 포함) 설치 및 환경 설정
- Eclipse 설치 및 환경 설정
- Visual Studio Code 설치 및 환경 설정
- Scoop(Win)/Homebrew(macOS) 패키지 관리자 설치
- Gradle 빌드 도구 설치
- Git 형상관리 도구 설치
- MariaDB 데이터베이스 설치

### 강의 자료 가져오기

- `github.com` 사이트에 가입하기
- `github.com/eomcs/eomcs-java-project-2021` 저장소를 로컬(개발 PC)로 복제하기

### 개인 저장소 만들기

- github.com 에 개인 저장소 만들기 
- github.com 의 개인 저장소를 로컬로 복제하기

## 버전 및 학습 목표

### 01-a. 프로젝트 준비하기 : Gradle 빌드 도구를 활용한 자바 프로젝트 구성
### 01-b. 프로젝트 준비하기 : `이클립스 IDE`로 임포트
### 01-c. 프로젝트 준비하기 : 버전 관리 시스템 Git 적용
 
### 02-a. 값 다루기 : 리터럴과 콘솔 출력
### 02-b. 값 다루기 : 변수와 키보드 입력
### 02-c. 값 다루기 : 배열과 흐름 제어문 활용

### 03-a. 메서드 사용법 : 프로그램의 시작점(entry point), `main()`
### 03-b. 메서드 사용법 : 메서드 활용

### 04-a. 클래스 사용법 : 메서드 분류
### 04-b. 클래스 사용법 : 새 데이터 타입 정의  
### 04-c. 클래스 사용법 : 패키지로 클래스 분류
### 04-d. 클래스 사용법 : 의존 관계

### 05-a. 인스턴스 사용법 : 클래스 필드와 클래스 메서드의 한계
### 05-b. 인스턴스 사용법 : 인스턴스 필드가 필요한 이유와 사용법
### 05-c. 인스턴스 사용법 : 인스턴스 메서드가 필요한 이유와 사용법

### 06-a. CRUD 구현하기
### 06-b. CRUD 구현하기 : 리팩토링

### 07-a. 의존 객체 다루기 : 인스턴스 필드에 직접 주입
### 07-b. 의존 객체 다루기 : 생성자로 주입

### 08-a. `Composite` 디자인 패턴 : 적용 전
### 08-b. `Composite` 디자인 패턴 : 적용 후
### 08-c. `Composite` 디자인 패턴 : 익명 클래스 활용
### 08-d. `Composite` 디자인 패턴 : 스태틱 멤버를 인스턴스 멤버로 전환

### 09-a. 데이터 처리 코드를 캡슐화 : 캡슐화 전 - 배열 크기 변경
### 09-b. 데이터 처리 코드를 캡슐화 : 캡슐화 전 - 연결리스트 적용
### 09-c. 데이터 처리 코드를 캡슐화 : 캡슐화 수행
### 09-d. 데이터 처리 코드를 캡슐화 : 캡슐화 후 -  배열 크기 변경
### 09-e. 데이터 처리 코드를 캡슐화 : 캡슐화 후 -  연결리스트 적용

### 10-a. 리팩토링 : Generalization
### 10-b. 리팩토링 : Generalization II
### 10-c. 리팩토링 : ArrayList를 직접 사용하기
### 10-d. 리팩토링 : LinkedList를 직접 사용하기
### 10-e. 리팩토링 : Generalization + 다형성 + 의존 객체 주입(Dependecy Injection)
### 10-f. 리팩토링 : 메서드 이동
### 10-g. 리팩토링 : 인터페이스 적용
### 10-h. 리팩토링 : 세터(setter), 게터(getter) 적용
### 10-i. 리팩토링 : 추상 클래스 적용

### 11-a. 자료 구조 다루기 : 스택 구현과 사용
### 11-b. 자료 구조 다루기 : 리팩토링 - 클래스 및 패키지 이동
### 11-c. 자료 구조 다루기 : 제네릭이 필요한 이유와 사용법
### 11-d. 자료 구조 다루기 : 자바 컬렉션 API 사용하기

### 12. 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법

### 13-a. 사용자 인증 : 로그인
### 13-b. 사용자 인증 : 내 정보 보기 
### 13-c. 사용자 인증 : 로그아웃
### 13-d. 사용자 인증 : 로그인 여부에 따라 메뉴 출력 제어
### 13-e. 사용자 인증 : 로그인 정보 활용

### 14-a. `Command` 디자인 패턴 : 적용 전 문제점 확인
### 14-b. `Command` 디자인 패턴 : 메서드를 객체로 분리
### 14-c. `Command` 디자인 패턴 : 리팩토링
### 14-d. `Command` 디자인 패턴 : 기능 추가를 통해 커맨드 패턴의 유용성 확인 
### 14-e. `Command` 디자인 패턴 : 인터페이스로 객체의 사용 규칙 통일
### 14-f. `Command` 디자인 패턴 : `Map`으로 커맨드 객체 관리

### 15. 비트 연산자 활용: 메뉴 권한 관리

### 16-a. 파일 입출력 다루기 : 바이너리 형식으로 데이터 입출력
### 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력

### 17-a. 메뉴 리팩토링: 상세보기에서 변경, 삭제 기능 수행하기
### 17-b. 메뉴 리팩토링: Command 인터페이스의 execute()에 파라미터 넘기기
### 17-c. 메뉴 리팩토링: Command 객체 간에 종속성 제거하기

### 18-a. `Observer` 디자인 패턴 : 옵저버 패턴이 필요한 이유
### 18-b. `Observer` 디자인 패턴 : 옵저버 패턴으로 구조를 바꾸기
### 18-c. `Observer` 디자인 패턴 : 옵저버로 파일 입출력 처리하기



### 21-a. 데이터 관리 서버 만들기 : 클라이언트/서버 프로젝트 준비
### 21-b. 데이터 관리 서버 만들기 : 간단한 메시지 송수신
### 21-c. 데이터 관리 서버 만들기 : 사용자가 입력한 명령처리
### 21-d. 데이터 관리 서버 만들기 : 프로토콜 정의 및 적용
### 21-e. 데이터 관리 서버 만들기 : 파일 및 데이터 처리 기능을 서버로 이전
### 21-f. 데이터 관리 서버 만들기 : 드라이버 객체 도입
### 21-g. 데이터 관리 서버 만들기 : 다중 클라이언트의 동시 접속 처리

### 22-a. 데이터 관리를 DBMS에게 맡기기 : JDBC API 사용
### 22-b. 데이터 관리를 DBMS에게 맡기기 : SQL 삽입 공격과 자바 시큐어 코딩
### 22-c. 데이터 관리를 DBMS에게 맡기기 : 무결성 제약 조건 및 트랜잭션
### 22-d. 데이터 관리를 DBMS에게 맡기기 : 무결성 제약 조건 II

### 23-a. 데이터 처리 코드를 캡슐화하기 : DAO 클래스 도입
### 23-b. 데이터 처리 코드를 캡슐화하기 : DAO 인터페이스 도입
### 23-c. 데이터 처리 코드를 캡슐화하기 : 의존 객체 주입과 DB 커넥션 객체 공유
### 23-d. 데이터 처리 코드를 캡슐화하기 : 트랜잭션이 필요한 이유와 명시적인 rollback

### 24-a. DB 프로그래밍을 더 쉽고 간단히 하는 방법 : Mybatis 퍼시스턴스 프레임워크 도입
### 24-b. DB 프로그래밍을 더 쉽고 간단히 하는 방법 : Mybatis의 기타 기능 활용
### 24-c. DB 프로그래밍을 더 쉽고 간단히 하는 방법 : Mybatis의 트랜잭션 제어

### 25-a. 비즈니스 로직 분리하기 : DAO에서 트랜잭션을 다룰 때의 한계
### 25-b. 비즈니스 로직 분리하기 : 서비스 객체의 도입
### 25-c. 비즈니스 로직 분리하기 : 서비스 객체를 인터페이스와 구현체로 분리

### 26-a. 객체 생성을 자동화하기 : Java Proxy를 이용한 DAO 구현체 자동 생성
### 26-b. 객체 생성을 자동화하기 : .propertis 파일을 이용한 Command 구현체 자동 생성
### 26-c. 객체 생성을 자동화하기 : 애노테이션을 이용한 Command 구현체 자동 생성

### 27-a. 애플리케이션을 클라이언트/서버 구조로 변경하기 : Stateful 방식의 통신 프로젝트 준비
### 27-b. 애플리케이션을 클라이언트/서버 구조로 변경하기 : 스레드풀 적용
### 27-c. 애플리케이션을 클라이언트/서버 구조로 변경하기 : 자바에서 제공하는 스레드풀 사용
### 27-d. 애플리케이션을 클라이언트/서버 구조로 변경하기 : PMS 코드를 C/S로 분리
### 27-e. 애플리케이션을 클라이언트/서버 구조로 변경하기 : 멀티스레드 환경에서 트랜잭션 제어

### 28-a. 세션(Session) 다루기 : 로그인/로그아웃 구현 + 세션 도입
### 28-b. 세션(Session) 다루기 : Stateless 통신 구현
### 28-c. 세션(Session) 다루기 : Stateless 통신에서 세션 유지 방법

### 29-a. `Chain of Responsibility` 디자인 패턴 : 프로젝트에 적용
### 29-b. `Chain of Responsibility` 디자인 패턴 : 필터 객체 자동 로딩 및 실행
### 29-c. `Chain of Responsibility` 디자인 패턴 : 로그인 검사를 필터로 분리

### 30-a. 웹 애플리케이션 서버 아키텍처로 전환하기 : Servlet 기술 도입
### 30-b. 웹 애플리케이션 서버 아키텍처로 전환하기 : `ServerApp`을 톰캣 서버로 대체하기
### 30-c. 웹 애플리케이션 서버 아키텍처로 전환하기 : `Command` 와 `Filter` 구현체를 Java EE 구현체로 바꾸기
### 30-d. 웹 애플리케이션 서버 아키텍처로 전환하기 : 웹 애플리케이션 배치를 자동화 하기

### 31-a. Servlet 기술 활용하기 : GET/POST 요청 구분과 HTML 도입하기 
### 31-b. Servlet 기술 활용하기 : 필터와 리스너 활용
### 31-c. Servlet 기술 활용하기 : 리프래시와 리다이렉트 활용 
### 31-d. Servlet 기술 활용하기 : 포워딩과 인클루딩 활용 
### 31-e. Servlet 기술 활용하기 : 쿠키와 세션 활용
### 31-f. Servlet 기술 활용하기 : 서블릿 예외 처리

### 32-a. MVC 아키텍처로 전환하기 : JSP를 활용하여 view 컴포넌트 분리하기
### 32-b. MVC 아키텍처로 전환하기 : JSP 엘리먼트와 JSP 액션 태그 사용하기
### 32-c. MVC 아키텍처로 전환하기 : EL 사용하기
### 32-d. MVC 아키텍처로 전환하기 : JSTL 사용하기

### 33-a. Front Controller 도입하기 : 프론트 컨트롤러 만들기
### 33-b. Front Controller 도입하기 : 페이지 컨트롤러를 일반 객체로 전환하기

### 34-a. Spring WebMVC 프레임워크 도입하기 : 스프링 WebMVC 적용
### 34-b. Spring WebMVC 프레임워크 도입하기 : CRUD 요청 핸들러 합치기
### 34-c. Spring WebMVC 프레임워크 도입하기 : GET/POST 요청 구분하기
### 34-d. Spring WebMVC 프레임워크 도입하기 : 요청 핸들러의 파라미터 다루기
### 34-e. Spring WebMVC 프레임워크 도입하기 : InternalResourceViewResolver 도입

### 35-a. 기타 : Log4j 적용
### 35-b. 기타 : 페이징 처리
### 35-c. 기타 : @PathVariable, @SessionAttributes, @ModelAttribute 다루기

### 32-e. MVC 아키텍처로 전환하기 : Bootstrap CSS 라이브러리 적용하기

### 46 - 객체 생성을 자동화하는 IoC 컨테이너 만들기

### 47 - IoC 컨테이너 개선 : 애노테이션을 이용한 객체 관리

### 48 - 인터페이스 대신 애노테이션으로 메서드 구분하기

### 50 - Spring IoC 컨테이너 도입하기

### 51 - Spring IoC 컨테이너와 MyBatis 연동하기

### 52 - 애노테이션을 이용하여 트랜잭션 제어하기

### 53 - Log4j를 사용하여 애플리케이션 로그 처리하기

### 54 - Web 기술 도입하기
