# mini-pms-v1

## 프로젝트 준비

### 개발 도구 준비하기

- GraalVM(OpenJDK 11 포함) 설치 및 환경 설정
- Eclipse 설치 및 환경 설정
- Visual Studio Code 설치 및 환경 설정
- Scoop(Win)/Homebrew(macOS) 패키지 관리자 설치
- Gradle 빌드 도구 설치
- Git 형상관리 도구 설치
- MariaDB 데이터베이스 설치

### 강의 자료 가져오기

- `github.com` 사이트에 가입하기
- `github.com/eomcs/eomcs-java-project-2021` 저장소를 로컬(개발 PC)로 복제하기

### 개인 저장소 만들기

- github.com 에 개인 저장소 만들기 
- github.com 의 개인 저장소를 로컬로 복제하기

## 버전 및 학습 목표

### 01-a. 프로젝트 준비하기 : Gradle 빌드 도구를 활용한 자바 프로젝트 구성
### 01-b. 프로젝트 준비하기 : `이클립스 IDE`로 임포트
### 01-c. 프로젝트 준비하기 : 버전 관리 시스템 Git 적용
 
### 02-a. 값 다루기 : 리터럴과 콘솔 출력
### 02-b. 값 다루기 : 변수와 키보드 입력
### 02-c. 값 다루기 : 배열과 흐름 제어문 활용

### 03-a. 메서드 사용법 : 프로그램의 시작점(entry point), `main()`
### 03-b. 메서드 사용법 : 메서드 활용

### 04-a. 클래스 사용법 : 메서드 분류
### 04-b. 클래스 사용법 : 새 데이터 타입 정의  
### 04-c. 클래스 사용법 : 패키지로 클래스 분류
### 04-d. 클래스 사용법 : 의존 관계

### 05-a. 인스턴스 사용법 : 클래스 필드와 클래스 메서드의 한계
### 05-b. 인스턴스 사용법 : 인스턴스 필드가 필요한 이유와 사용법
### 05-c. 인스턴스 사용법 : 인스턴스 메서드가 필요한 이유와 사용법

### 06-a. CRUD 구현하기
### 06-b. CRUD 구현하기 : 리팩토링

### 07-a. 의존 객체 다루기 : 인스턴스 필드에 직접 주입
### 07-b. 의존 객체 다루기 : 생성자로 주입

### 08-a. `Composite` 디자인 패턴 : 적용 전
### 08-b. `Composite` 디자인 패턴 : 적용 후
### 08-c. `Composite` 디자인 패턴 : 익명 클래스 활용
### 08-d. `Composite` 디자인 패턴 : 스태틱 멤버를 인스턴스 멤버로 전환

### 09-a. 데이터 처리 코드를 캡슐화 : 캡슐화 전 - 배열 크기 변경
### 09-b. 데이터 처리 코드를 캡슐화 : 캡슐화 전 - 연결리스트 적용
### 09-c. 데이터 처리 코드를 캡슐화 : 캡슐화 수행
### 09-d. 데이터 처리 코드를 캡슐화 : 캡슐화 후 -  배열 크기 변경
### 09-e. 데이터 처리 코드를 캡슐화 : 캡슐화 후 -  연결리스트 적용

### 10-a. 리팩토링 : Generalization
### 10-b. 리팩토링 : Generalization II
### 10-c. 리팩토링 : ArrayList를 직접 사용하기
### 10-d. 리팩토링 : LinkedList를 직접 사용하기
### 10-e. 리팩토링 : Generalization + 다형성 + 의존 객체 주입(Dependecy Injection)
### 10-f. 리팩토링 : 메서드 이동
### 10-g. 리팩토링 : 인터페이스 적용
### 10-h. 리팩토링 : 세터(setter), 게터(getter) 적용
### 10-i. 리팩토링 : 추상 클래스 적용

### 11-a. 자료 구조 다루기 : 스택 구현과 사용
### 11-b. 자료 구조 다루기 : 리팩토링 - 클래스 및 패키지 이동
### 11-c. 자료 구조 다루기 : 제네릭이 필요한 이유와 사용법
### 11-d. 자료 구조 다루기 : 자바 컬렉션 API 사용하기

### 12. 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법

### 13-a. 사용자 인증 : 로그인
### 13-b. 사용자 인증 : 내 정보 보기 
### 13-c. 사용자 인증 : 로그아웃
### 13-d. 사용자 인증 : 로그인 여부에 따라 메뉴 출력 제어
### 13-e. 사용자 인증 : 로그인 정보 활용

### 14-a. `Command` 디자인 패턴 : 적용 전 문제점 확인
### 14-b. `Command` 디자인 패턴 : 메서드를 객체로 분리
### 14-c. `Command` 디자인 패턴 : 리팩토링
### 14-d. `Command` 디자인 패턴 : 기능 추가를 통해 커맨드 패턴의 유용성 확인 
### 14-e. `Command` 디자인 패턴 : 인터페이스로 객체의 사용 규칙 통일
### 14-f. `Command` 디자인 패턴 : `Map`으로 커맨드 객체 관리

### 15. 비트 연산자 활용: 메뉴 권한 관리

### 16-a. 파일 입출력 다루기 : 바이너리 형식으로 데이터 입출력
### 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력

### 17-a. 메뉴 리팩토링: 상세보기에서 변경, 삭제 기능 수행하기
### 17-b. 메뉴 리팩토링: Command 인터페이스의 execute()에 파라미터 넘기기
### 17-c. 메뉴 리팩토링: Command 객체 간에 종속성 제거하기

### 18-a. `Observer` 디자인 패턴 : 옵저버 패턴이 필요한 이유
### 18-b. `Observer` 디자인 패턴 : 옵저버 패턴으로 구조를 바꾸기
### 18-c. `Observer` 디자인 패턴 : 옵저버로 파일 입출력 처리하기

### 19-a. 데이터 관리 서버 만들기 : 클라이언트/서버 프로젝트 준비
### 19-b. 데이터 관리 서버 만들기 : 간단한 메시지 송수신
### 19-c. 데이터 관리 서버 만들기 : 사용자가 입력한 명령처리
### 19-d. 데이터 관리 서버 만들기 : 프로토콜 정의 및 적용
### 19-e. 데이터 관리 서버 만들기 : 통신 기능을 캡슐화
### 19-f. 데이터 관리 서버 만들기 : 파일 및 데이터 처리 기능을 서버로 이전
### 19-g. 데이터 관리 서버 만들기 : 다중 클라이언트의 접속 처리(Stateful)
### 19-h. 데이터 관리 서버 만들기 : 다중 클라이언트의 접속 처리(Stateless)
### 19-i. 데이터 관리 서버 만들기 : 다중 클라이언트의 동시 접속 처리(Stateless + Multi-Thread)

### 20-a. 데이터 처리 코드를 캡슐화하기 : DAO 클래스 도입

### 21-a. 데이터 관리를 DBMS에게 맡기기 : JDBC API 사용

### 22-a. DB 프로그래밍을 더 쉽고 간단히 하는 방법 : Mybatis 퍼시스턴스 프레임워크 도입
### 22-b. DB 프로그래밍을 더 쉽고 간단히 하는 방법 : Mybatis에서 DAO 구현체를 자동으로 생성하기

### 23-a. 웹 애플리케이션 서버 아키텍처로 전환하기 : Servlet/JSP 기술 도입
### 23-b. 웹 애플리케이션 서버 아키텍처로 전환하기 : MVC 패턴 적용
### 23-c. 웹 애플리케이션 서버 아키텍처로 전환하기 : EL, JSTL 적용
### 23-d. 웹 애플리케이션 서버 아키텍처로 전환하기 : Bootstrap 적용
### 23-e. 웹 애플리케이션 서버 아키텍처로 전환하기 : JavaScript 적용 + POST + 필터 적용
### 23-f. 웹 애플리케이션 서버 아키텍처로 전환하기 : 템플릿 적용
### 23-g. 웹 애플리케이션 서버 아키텍처로 전환하기 : get/post, 파일 업로드, 썸네일, 로그인/로그아웃, 쿠키 적용
### 23-h. 웹 애플리케이션 서버 아키텍처로 전환하기 : 프론트 컨트롤러 도입


### 24-a. Spring WebMVC 프레임워크 도입하기 : 프레임워크 적용
### 24-b. Spring WebMVC 프레임워크 도입하기 : Java Config 설정
### 24-c. Spring WebMVC 프레임워크 도입하기 : 서비스 객체 도입

